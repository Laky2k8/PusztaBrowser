#pragma once

#include <glad/glad.h>
#define GLFW_INCLUDE_NONE      // if you include GLFW anywhere in this header
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <map>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <codecvt>
#include <locale>
#include "laky_shader.h"

// FreeType header
#include <ft2build.h>
#include FT_FREETYPE_H 

using namespace std;

FT_Library ft; // FreeType library handle
FT_Face face; // FreeType font face handle

struct Character {
    unsigned int TextureID;  // ID handle of the glyph texture
    glm::ivec2   Size;       // Size of glyph
    glm::ivec2   Bearing;    // Offset from baseline to left/top of glyph
    unsigned int Advance;    // Offset to advance to next glyph
};

struct FontInfo {
    FT_Face face;
    map<char32_t, Character> characters;
    string font_path;
    bool loaded;
    
    FontInfo() : face(nullptr), loaded(false) {}
};

glm::mat4 projection;

map<string, FontInfo> fonts;
string current_font = ""; // Track current active font

unsigned int global_text_VAO = 0;
unsigned int global_text_VBO = 0;

// Initialize once during startup
void init_text_rendering_buffers() {
    if (global_text_VAO == 0) {
        glGenVertexArrays(1, &global_text_VAO);
        glGenBuffers(1, &global_text_VBO);
        glBindVertexArray(global_text_VAO);
        glBindBuffer(GL_ARRAY_BUFFER, global_text_VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }
}


int lfh_init_freetype(float screen_width, float screen_height)
{
    setlocale(LC_ALL, "");
    
    // Use screen coordinates: (0,0) at top-left, (width,height) at bottom-right
    projection = glm::ortho(0.0f, screen_width, 0.0f, screen_height);
    
    cout << "Initializing FreeType with screen size: " << screen_width << "x" << screen_height << endl;

    // Initialize FreeType library once
    if (FT_Init_FreeType(&ft))
    {
        cerr << "LFH ERROR::FREETYPE: Could not init FreeType Library" << endl;
        return -1;
    }
    
    return 0;
}

int load_font(const string& font_name, const char* font_path)
{
    // Check if font already exists
    if (fonts.find(font_name) != fonts.end() && fonts[font_name].loaded) {
        cout << "Font '" << font_name << "' already loaded" << endl;
        return 0;
    }
    
    FontInfo& font_info = fonts[font_name];
    
    // Load the font face
    if (FT_New_Face(ft, font_path, 0, &font_info.face))
    {
        cerr << "LFH ERROR::FREETYPE: Failed to load font: " << font_path << endl;
        fonts.erase(font_name); // Remove failed entry
        return -1;
    }
    
    FT_Select_Charmap(font_info.face, FT_ENCODING_UNICODE);
    
    font_info.font_path = font_path;
    font_info.loaded = true;
    
    cout << "Successfully loaded font '" << font_name << "': " << font_path << endl;
    
    // Set as current font if it's the first one loaded
    if (current_font.empty()) {
        current_font = font_name;
    }
    
    return 0;
}

void load_characters(const string& font_name, int glyph_size)
{

    auto font_it = fonts.find(font_name);
    if (font_it == fonts.end() || !font_it->second.loaded) {
        cerr << "LFH ERROR: Font '" << font_name << "' not found or not loaded" << endl;
        return;
    }
    
    FontInfo& font_info = font_it->second;
    FT_Face& face = font_info.face;

    FT_Select_Charmap(face, FT_ENCODING_UNICODE);
	FT_Set_Pixel_Sizes(face, 0, glyph_size);

    // Clear character map for this font
    // Clean up existing textures first
    for (auto& pair : font_info.characters) {
        glDeleteTextures(1, &pair.second.TextureID);
    }
    font_info.characters.clear();

	glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // Disable byte-alignment restriction

	for (wchar_t c = 0x0; c <= 0x024F; ++c)
	{
		// Load character glyph
		if(FT_Load_Char(face, c, FT_LOAD_RENDER))
		{
			cerr << "LFH ERROR::FREETYPE: Failed to load glyph " << c << endl;
			continue;
		}

		// Generate texture
		unsigned int texture;
		glGenTextures(1, &texture);
		glBindTexture(GL_TEXTURE_2D, texture);
		glTexImage2D(
			GL_TEXTURE_2D,
			0,
			GL_RED,
			face->glyph->bitmap.width,
			face->glyph->bitmap.rows,
			0,
			GL_RED,
			GL_UNSIGNED_BYTE,
			face->glyph->bitmap.buffer
		);

		// Set texture options
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // Save into hashmap
        Character character = {
            texture, 
            glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),
            glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),
            face->glyph->advance.x
        };
        font_info.characters.insert({c, character});
    }
    
    cout << "Loaded " << font_info.characters.size() << " characters for font '" << font_name << "'" << endl;

}

// Set the active font for rendering
bool set_active_font(const string& font_name)
{
    auto font_it = fonts.find(font_name);
    if (font_it == fonts.end() || !font_it->second.loaded) {
        cerr << "LFH ERROR: Cannot set active font '" << font_name << "' - not found or not loaded" << endl;
        return false;
    }
    
    current_font = font_name;
    return true;
}

// Get current active font name
string get_active_font()
{
    return current_font;
}

// Render text with specified font
void render_text(Shader &s, const string& font_name, string text, float x, float y, float scale, glm::vec3 color, float screen_width, float screen_height)
{
    auto font_it = fonts.find(font_name);
    if (font_it == fonts.end() || !font_it->second.loaded) {
        cerr << "LFH ERROR: Font '" << font_name << "' not found or not loaded" << endl;
        return;
    }
    
    const map<char32_t, Character>& Characters = font_it->second.characters;
    
    // Early exit if text would be completely off-screen
    /*if (y > screen_height || y + scale * 50 < 0) { // Rough height estimate
        return;
    }*/
    
    projection = glm::ortho(0.0f, screen_width, 0.0f, screen_height);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);  

    // Use pre-created VAO/VBO instead of creating new ones
    glBindVertexArray(global_text_VAO);

    // Only set shader state once per call
    s.use();
    s.setVec3f("textColor", color);
    s.setMat4("projection", projection);
    s.setInt("text", 0);

    glActiveTexture(GL_TEXTURE0);

    float initial_x = x;

    // Convert to wide string for Unicode support
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
    std::u32string utf32;
    bool unicode_rendering = true;
    try {
        utf32 = conv.from_bytes(text);
    } catch (const std::range_error& e) {
        unicode_rendering = false;
    }

    // iterate through all characters
    if(unicode_rendering)
    {
        for (char32_t codepoint : utf32)
        {
            auto it = Characters.find(codepoint);
            if (it == Characters.end()) continue;
            const Character& ch = it->second;

            if (codepoint == U'\n') {
                x = initial_x;
                y -= ch.Size.y * scale;
                continue;
            }

            if (codepoint == U'\t') {
                auto space_it = Characters.find(' ');
                if (space_it != Characters.end()) {
                    x += 8 * (space_it->second.Advance >> 6) * scale;
                }
                continue;
            }

            if (codepoint < 32) continue;

            float xpos = x + ch.Bearing.x * scale;
            float ypos = y - (ch.Size.y - ch.Bearing.y) * scale;
            float w = ch.Size.x * scale;
            float h = ch.Size.y * scale;

            // Enhanced culling check
            if (xpos + w < 0 || xpos > screen_width || ypos + h < 0 || ypos > screen_height) {
                x += (ch.Advance >> 6) * scale; // Still advance cursor
                continue;
            }

            float vertices[6][4] = {
                { xpos,     ypos + h,   0.0f, 0.0f },            
                { xpos,     ypos,       0.0f, 1.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos,     ypos + h,   0.0f, 0.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos + w, ypos + h,   1.0f, 0.0f }           
            };

            glBindTexture(GL_TEXTURE_2D, ch.TextureID);
            glBindBuffer(GL_ARRAY_BUFFER, global_text_VBO);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); 
            glDrawArrays(GL_TRIANGLES, 0, 6);
            
            x += (ch.Advance >> 6) * scale;
        }
    }
    else
    {
        // Similar optimizations for ASCII path...
        for (char c : text)
        {
            auto it = Characters.find(c);
            if (it == Characters.end()) continue;
            const Character& ch = it->second;

            if (c == '\n') {
                x = initial_x;
                y -= ch.Size.y * scale;
                continue;
            }

            if (c == '\t') {
                auto space_it = Characters.find(' ');
                if (space_it != Characters.end()) {
                    x += 8 * (space_it->second.Advance >> 6) * scale;
                }
                continue;
            }

            if (c < 32 || c > 126) continue;

            float xpos = x + ch.Bearing.x * scale;
            float ypos = y - (ch.Size.y - ch.Bearing.y) * scale;
            float w = ch.Size.x * scale;
            float h = ch.Size.y * scale;

            if (xpos + w < 0 || xpos > screen_width || ypos + h < 0 || ypos > screen_height) {
                x += (ch.Advance >> 6) * scale;
                continue;
            }

            float vertices[6][4] = {
                { xpos,     ypos + h,   0.0f, 0.0f },            
                { xpos,     ypos,       0.0f, 1.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos,     ypos + h,   0.0f, 0.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos + w, ypos + h,   1.0f, 0.0f }           
            };

            glBindTexture(GL_TEXTURE_2D, ch.TextureID);
            glBindBuffer(GL_ARRAY_BUFFER, global_text_VBO);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); 
            glDrawArrays(GL_TRIANGLES, 0, 6);
            
            x += (ch.Advance >> 6) * scale;
        }
    }
    
    glBindVertexArray(0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}

// Convenience function to render with current active font
void render_text(Shader &s, string text, float x, float y, float scale, glm::vec3 color, float screen_width, float screen_height)
{
    if (current_font.empty()) {
        cerr << "LFH ERROR: No active font set" << endl;
        return;
    }
    render_text(s, current_font, text, x, y, scale, color, screen_width, screen_height);
}

float calculate_content_height(const string& font_name, const std::string& text, float scale, float screen_width) {
    auto font_it = fonts.find(font_name);
    if (font_it == fonts.end() || !font_it->second.loaded) {
        cerr << "LFH ERROR: Font '" << font_name << "' not found or not loaded" << endl;
        return 0.0f;
    }
    
    const map<char32_t, Character>& Characters = font_it->second.characters;
    
    if (text.empty()) return 0.0f;
    
    float x = 0.0f;
    float y = 0.0f;
    float max_y = 0.0f;
    float line_height = 0.0f;
    
    // Calculate line height from the tallest character
    if (Characters.find('A') != Characters.end()) {
        line_height = Characters.find('A')->second.Size.y * scale;
    } else if (!Characters.empty()) {
        line_height = Characters.begin()->second.Size.y * scale;
    }
    
    // Convert to wide string for Unicode support
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
    std::u32string utf32;
    bool unicode_rendering = true;
    
    try {
        utf32 = conv.from_bytes(text);
    } catch (const std::range_error& e) {
        unicode_rendering = false;
    }
    
    if (unicode_rendering) {
        for (char32_t codepoint : utf32) {
            // Check if codepoint is in your Characters map
            auto it = Characters.find(codepoint);
            if (it == Characters.end()) continue;
            
            const Character& ch = it->second;
            
            // Handle newline character
            if (codepoint == U'\n') {
                x = 0.0f;
                y += line_height; 
                max_y = std::max(max_y, y + line_height);
                continue;
            }
            
            // Handle tab character
            if (codepoint == U'\t') {
                auto space_it = Characters.find(' ');
                if (space_it != Characters.end()) {
                    x += 8 * (space_it->second.Advance >> 6) * scale;
                }
                continue;
            }
            
            // Skip control characters
            if (codepoint < 32) {
                continue;
            }
            
            float char_width = (ch.Advance >> 6) * scale;
            float char_height = ch.Size.y * scale;
            
            // Check if character would exceed screen width (word wrapping)
            if (x + char_width > screen_width && x > 0) {
                x = 0.0f; 
                y += line_height;
            }
            
            // Update max_y to track the bottom of the content
            max_y = std::max(max_y, y + char_height);
            
            // Advance x position
            x += char_width;
        }
    } else {
        // Fallback to ASCII rendering
        for (char c : text) {
            auto it = Characters.find(c);
            if (it == Characters.end()) continue;
            
            const Character& ch = it->second;
            
            // Handle newline character
            if (c == '\n') {
                x = 0.0f;
                y += line_height;
                max_y = std::max(max_y, y + line_height);
                continue;
            }
            
            // Handle tab character
            if (c == '\t') {
                auto space_it = Characters.find(' ');
                if (space_it != Characters.end()) {
                    x += 8 * (space_it->second.Advance >> 6) * scale;
                }
                continue;
            }
            
            // Skip control characters
            if (c < 32 || c > 126) {
                continue;
            }
            
            float char_width = (ch.Advance >> 6) * scale;
            float char_height = ch.Size.y * scale;
            
            // Check if character would exceed screen width (word wrapping)
            if (x + char_width > screen_width && x > 0) {
                x = 0.0f;
                y += line_height;
            }
            
            // Update max_y to track the bottom of the content
            max_y = std::max(max_y, y + char_height);
            
            // Advance x position
            x += char_width;
        }
    }
    
    // Return the total height needed
    return max_y > 0 ? max_y : line_height;
}

// Convenience function for current active font
float calculate_content_height(const std::string& text, float scale, float screen_width) {
    if (current_font.empty()) {
        cerr << "LFH ERROR: No active font set" << endl;
        return 0.0f;
    }
    return calculate_content_height(current_font, text, scale, screen_width);
}

// Get list of loaded fonts
vector<string> get_loaded_fonts()
{
    vector<string> font_names;
    for (const auto& pair : fonts) {
        if (pair.second.loaded) {
            font_names.push_back(pair.first);
        }
    }
    return font_names;
}

// Unload a specific font
void unload_font(const string& font_name)
{
    auto font_it = fonts.find(font_name);
    if (font_it == fonts.end()) {
        return;
    }
    
    FontInfo& font_info = font_it->second;
    
    // Clean up character textures
    for (auto& pair : font_info.characters) {
        glDeleteTextures(1, &pair.second.TextureID);
    }
    
    // Clean up FreeType face
    if (font_info.face) {
        FT_Done_Face(font_info.face);
    }
    
    // Remove from map
    fonts.erase(font_it);
    
    // If this was the current font, clear current font
    if (current_font == font_name) {
        current_font = "";
        // Optionally set to first available font
        if (!fonts.empty()) {
            current_font = fonts.begin()->first;
        }
    }
    
    cout << "Unloaded font: " << font_name << endl;
}

// Add cleanup function
void lfh_cleanup()
{
    // Clean up all fonts
    for (auto& pair : fonts) {
        FontInfo& font_info = pair.second;
        
        // Clean up character textures
        for (auto& char_pair : font_info.characters) {
            glDeleteTextures(1, &char_pair.second.TextureID);
        }
        
        // Clean up FreeType face
        if (font_info.face) {
            FT_Done_Face(font_info.face);
        }
    }
    
    fonts.clear();
    current_font = "";

    glDeleteVertexArrays(1, &global_text_VAO);
    glDeleteBuffers(1, &global_text_VBO);
    global_text_VAO = 0;
    global_text_VBO = 0;
    
    // Clean up FreeType library
    FT_Done_FreeType(ft);
}