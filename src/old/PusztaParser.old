#ifndef PUSZTAPARSER_HPP
#define PUSZTAPARSER_HPP

#include <string>
#include <vector>
#include <variant>
#include <iostream>
#include "laky_shader.h"
#include "lakys-freetype-handler.hpp"
#include "StringSplitter.hpp"
#include <map>
#include <algorithm>
#include <stack>

using namespace std;

class Text
{
	private:
		string text;

	public:
		Text(const string& text) : text(text) {}

		string get_text() const
		{
			return text;
		}

		void set_text(const string& new_text)
		{
			text = new_text;
		}
};

class Tag
{
	private:
		string tag;

	public:
		Tag(const string& tag) : tag(tag) {}

		string get_tag() const
		{
			return tag;
		}

		void set_tag(const string& new_tag)
		{
			tag = new_tag;
		}
};

using Token = std::variant<Text, Tag>;

static string find_font_variant(
    const vector<string>& available_fonts,
    const string& base_name,
    const string& style)
{
    string key = base_name + "_" + style;
    auto it = find(available_fonts.begin(), available_fonts.end(), key);
    return (it != available_fonts.end()) ? *it : string();
}

bool contains(const std::string& haystack, const std::string& needle) {
    return haystack.find(needle) != std::string::npos;
}

class Layout
{
	private:

		Shader &s; // Reference to the shader used for rendering

		float cursor_x, cursor_y;
		float weight;
		string style;

		map<string,string> font_types;
		string font;

		vector<Token> tokens;

	public:
		Layout(Shader &s, float start_x, float start_y, map<string,string> types)
		{
			s = s; // Initialize the shader reference
			cursor_x = start_x;
			cursor_y = start_y;
			weight = 400.0f;
			style = "regular";
			font_types = types; // Types of a font like regular and italic


			try
			{
				font = types[style];
			}
			catch (...)
			{
				cerr << "Incorrect font types map supplied!";
				exit(1);
			}
		}


		void lex(string body)
		{
			string buffer = "";
			vector<Token> out;
			bool in_tag = false;


			for (int i = 0; i < body.size(); i++)
			{
				char c = body[i];

				if(c == '<')
				{
					in_tag = true; // Start of a tag

					if(!buffer.empty())
					{
						Text textToken(buffer);
						out.emplace_back(textToken);
						buffer.clear();
					}
				}
				else if(c == '>')
				{
					in_tag = false; // End of a tag
					cout << "Found tag: " << buffer << endl;

					if(!buffer.empty())
					{
						Tag tagToken(buffer);
						out.emplace_back(tagToken);
						buffer.clear();
					}
				}
				else
				{
					buffer += c;

					//cout << "Buffer: " << buffer << endl;
				}


			}

			if(!in_tag && !buffer.empty())
			{
				Text textToken(buffer);
				out.emplace_back(textToken);
			}

			this->tokens = out;

		}

		// RENDERING

		void render(float screen_width, float screen_height, float text_size)
		{

			float font_size = text_size; // Base font size
			float line_height = font_size * 1.2f; // Standard line height

			stack<bool> render_stack;
			render_stack.push(true); // Start with rendering enabled


			for (const auto& tok : tokens) {

				// Print if token is Tag
				/*if (const Tag* pTag = get_if<Tag>(&tok)) {
					cout << "Tag token: " << pTag->get_tag() << endl;
				}
				else if (const Text* pText = get_if<Text>(&tok)) {
					cout << "Text token: " << pText->get_text() << endl;
				}*/

				if (const Text* pText = get_if<Text>(&tok)) {
					//cout << "Text token: " << pText->get_text() << endl;

					// Check if token is empty or whitespace
					string text = pText->get_text();
					if (text.empty() || 
						all_of(text.begin(), text.end(), [](unsigned char c) { 
							return ::isspace(c); 
						})) {
						//cout << "Skipping whitespace text token" << endl;
						continue;  // Skip this token entirely
					}

					// Early culling - don't render if way off screen
					if (y > screen_height + line_height || y < -line_height) {
						//cout << "Skipping token: " << text << " (off screen)" << endl;
						y -= calculate_content_height(regular_font, text, font_size, screen_width) * 1.2f;
						continue;
					}

					if(render_stack.top())
					{
						//cout << "women be rendering" << endl;
						render_text(s, pText->get_text(), x, y, font_size, glm::vec3(0.0f, 0.0f, 0.0f), screen_width, screen_height);
					}
					else
					{
						//cout << "No text rendering lmao" << endl;
					}
					

					float text_width = text.size() * font_size * 0.6f; // Rough estimate

					// Next line
					y -= calculate_content_height(regular_font, pText->get_text(), font_size, screen_width) * 1.2f;
				
				}
				else if (const Tag* pTag = get_if<Tag>(&tok)) {
					// tok holds a Tag
					string tagName = pTag->get_tag();
					//cout << "Tag token: " << tagName << endl;

					vector<string> supported_tags = {"b", "strong", "i", "em", "h1", "p", "big", "small"};
					bool isClosingTag = (tagName[0] == '/');
					string tag_clean = "";

					if (isClosingTag) 
					{
						// For closing tags, remove the '/' and get the tag name
						string temp_tag = tagName.substr(1);
						vector<string> tag_parts = split(temp_tag, " ");
						if (!tag_parts.empty()) {
							tag_clean = tag_parts[0];
						} else {
							tag_clean = temp_tag;
						}
						
						// Pop the render stack for closing tags
						if(render_stack.size() > 1) {
							render_stack.pop();
						}
					} 
					else 
					{
						// For opening tags, just clean the tag name
						vector<string> tag_parts = split(tagName, " ");
						if (!tag_parts.empty()) {
							tag_clean = tag_parts[0];
						} else {
							tag_clean = tagName;
						}
					}

					if(find(supported_tags.begin(), supported_tags.end(), tag_clean) == supported_tags.end())
					{
						//cerr << "LFH ERROR: Unsupported tag: " << tag_clean << endl;
						render_stack.push(false); // Push false for unsupported tag
						continue;
					}
					else
					{
						render_stack.push(true);
					}

					if(tag_clean == "b" || tag_clean == "strong")
					{
						font_weight = 700.0f; 
					}

					else if(tag_clean == "i" || tag_clean == "em")
					{
						is_italic = true;


					}

					else if(tag_clean == "h1")
					{
						font_size = text_size * 2;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "big")
					{
						font_size = text_size * 2;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "small")
					{
						font_size = text_size / 2;
						line_height = font_size * 1.2f;
					}



					else if(tag_clean == "p")
					{
						font_size = text_size;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "/b" || tag_clean == "/strong")
					{
						font_weight = 400.0f; // Reset to regular weight
					}

					else if(tag_clean == "/i" || tag_clean == "/em")
					{
						is_italic = false; // Reset italic state

					}

					else if(tag_clean == "/h1")
					{
						font_size = text_size;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "/big")
					{
						font_size = text_size;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "/small")
					{
						font_size = text_size;
						line_height = font_size * 1.2f;
					}

					else if(tag_clean == "/p")
					{
						font_size = text_size;
						line_height = font_size * 1.2f;
					}

					if(is_italic)
					{
						if(!italic_font.empty())
						{
							set_active_font(italic_font);
						}
						else
						{
							cerr << "LFH ERROR: Italic font not found!" << endl;
						}
					}
					else
					{
						if(!regular_font.empty())
						{
							set_active_font(regular_font);
						}
						else
						{
							cerr << "LFH ERROR: Regular font not found!" << endl;
						}
					}

					set_font_weight(regular_font, font_weight);


				}
			}
		}
};




/*string parse_remove_tags(string body)
{
	string cleaned = "";

	bool in_tag = false;

	for (int i = 0; i < body.size(); i++)
	{
		char c = body[i];

		if(c == '<')
		{
			in_tag = true; // Start of a tag
		}
		else if(c == '>')
		{
			in_tag = false; // End of a tag
			cleaned += ' '; // Add space after the tag
		}

		// Only return content that is not a tag
		else if(!in_tag)
		{
			cleaned += c;
		}
	}

	return cleaned;

}*/

// RENDERING




/*float calculate_token_content_height(const vector<string>& available_fonts, const vector<Token>& tokens, float text_size, float screen_width)
{
	// Font naming convention: <font_name>_<style>
	string regular_font = find_font_variant(available_fonts, "rubik", "regular");
	string bold_font = find_font_variant(available_fonts, "rubik", "bold");
	string italic_font = find_font_variant(available_fonts, "rubik", "italic");
	string bold_italic_font = find_font_variant(available_fonts, "rubik", "bold_italic");

	float total_height = 0.0f;
	float current_y = 0.0f;

	for (const auto& tok : tokens) {
		if (const Text* pText = get_if<Text>(&tok)) {
			total_height += calculate_content_height(regular_font, pText->get_text(), text_size, screen_width);
		}
		else if (const Tag* pTag = get_if<Tag>(&tok)) {
			string tagName = pTag->get_tag();

			if(tagName == "h1")
			{
				total_height += text_size * 2; // Example height for h1
			}
			else if(tagName == "p")
			{
				total_height += text_size; // Example height for paragraph
			}
		}
	}

	return total_height;
}*/





#endif